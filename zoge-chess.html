<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>ZOGE Chess</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(135deg, #ff6b6b, #ffd93d);
      color: #333;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 10px;
      overflow: hidden;
      touch-action: manipulation;
    }
    .container {
      text-align: center;
      max-width: 100%;
      width: 90vw;
      position: relative;
    }
    h1 {
      font-size: 1.8rem;
      color: #ff6b6b;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
      margin-bottom: 10px;
    }
    #chessboard {
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      border-radius: 10px;
      max-width: 100%;
      height: auto;
      animation: fadeIn 0.8s ease-in-out;
      position: relative;
      z-index: 1;
    }
    #background {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90vw;
      height: auto;
      opacity: 0.2;
      z-index: 0;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    #status {
      margin-top: 10px;
      font-size: 1rem;
      color: #fff;
      text-shadow: 1px 1px 2px #000;
    }
    @media (max-width: 600px) {
      #chessboard { max-width: 90vw; }
      h1 { font-size: 1.5rem; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ZOGE Chess</h1>
    <img id="background" src="https://i.postimg.cc/J0dDKhzB/grok-image-xcu1re3.jpg" alt="Chess Couple">
    <canvas id="chessboard"></canvas>
    <div id="status">White's turn</div>
  </div>

  <script>
    const canvas = document.getElementById('chessboard');
    const ctx = canvas.getContext('2d');

    // Dynamic size
    let cellSize = Math.min(window.innerWidth * 0.9 / 8, 60);
    canvas.width = cellSize * 8;
    canvas.height = cellSize * 8;

    // Piece images (free from Wikimedia Commons)
    const pieces = {
      'wp': 'https://upload.wikimedia.org/wikipedia/commons/0/04/Chess_plt60.png',
      'wn': 'https://upload.wikimedia.org/wikipedia/commons/2/28/Chess_nlt60.png',
      'wb': 'https://upload.wikimedia.org/wikipedia/commons/9/9b/Chess_blt60.png',
      'wr': 'https://upload.wikimedia.org/wikipedia/commons/a/a0/Chess_rlt60.png',
      'wq': 'https://upload.wikimedia.org/wikipedia/commons/4/49/Chess_qlt60.png',
      'wk': 'https://upload.wikimedia.org/wikipedia/commons/3/3b/Chess_klt60.png',
      'bp': 'https://upload.wikimedia.org/wikipedia/commons/c/cd/Chess_pdt60.png',
      'bn': 'https://upload.wikimedia.org/wikipedia/commons/f/f1/Chess_ndt60.png',
      'bb': 'https://upload.wikimedia.org/wikipedia/commons/8/81/Chess_bdt60.png',
      'br': 'https://upload.wikimedia.org/wikipedia/commons/a/af/Chess_rdt60.png',
      'bq': 'https://upload.wikimedia.org/wikipedia/commons/8/8e/Chess_qdt60.png',
      'bk': 'https://upload.wikimedia.org/wikipedia/commons/e/e3/Chess_kdt60.png'
    };

    // Load images
    const images = {};
    let imagesLoaded = 0;
    const totalImages = Object.keys(pieces).length;

    function loadImages() {
      for (let key in pieces) {
        images[key] = new Image();
        images[key].onload = () => {
          imagesLoaded++;
          if (imagesLoaded === totalImages) {
            initializeGame();
          }
        };
        images[key].onerror = () => {
          document.getElementById('status').textContent = 'Error loading images. Try again later.';
        };
        images[key].src = pieces[key];
      }
    }

    // Board state
    let board = [
      ['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br'],
      ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'],
      ['', '', '', '', '', '', '', ''],
      ['', '', '', '', '', '', '', ''],
      ['', '', '', '', '', '', '', ''],
      ['', '', '', '', '', '', '', ''],
      ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'],
      ['wr', 'wn', 'wb', 'wq', 'wk', 'wb', 'wn', 'wr']
    ];

    let selected = null;
    let turn = 'w'; // 'w' for white, 'b' for black

    // Draw board
    function drawBoard() {
      for (let y = 0; y < 8; y++) {
        for (let x = 0; x < 8; x++) {
          ctx.fillStyle = (x + y) % 2 === 0 ? '#f0d9b5' : '#b58863';
          ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
          const piece = board[y][x];
          if (piece && images[piece].complete) {
            ctx.drawImage(images[piece], x * cellSize, y * cellSize, cellSize, cellSize);
          }
        }
      }
      if (selected) {
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = 'yellow';
        ctx.fillRect(selected.x * cellSize, selected.y * cellSize, cellSize, cellSize);
        ctx.globalAlpha = 1.0;
      }
      document.getElementById('status').textContent = `${turn === 'w' ? 'White' : 'Black'}'s turn`;
    }

    // Get moves for all pieces
    function getMoves(piece, x, y) {
      const moves = [];
      if (!piece) return moves;

      // Pawn
      if (piece[1] === 'p') {
        const dir = piece[0] === 'w' ? -1 : 1;
        const startY = piece[0] === 'w' ? 6 : 1;
        if (y + dir >= 0 && y + dir < 8 && !board[y + dir][x]) {
          moves.push({x, y: y + dir});
          if (y === startY && !board[y + 2 * dir][x]) {
            moves.push({x, y: y + 2 * dir});
          }
        }
        if (y + dir >= 0 && y + dir < 8) {
          if (x - 1 >= 0 && board[y + dir][x - 1] && board[y + dir][x - 1][0] !== piece[0]) {
            moves.push({x: x - 1, y: y + dir});
          }
          if (x + 1 < 8 && board[y + dir][x + 1] && board[y + dir][x + 1][0] !== piece[0]) {
            moves.push({x: x + 1, y: y + dir});
          }
        }
      }

      // Rook (horizontal and vertical)
      if (piece[1] === 'r') {
        for (let i = x + 1; i < 8; i++) if (!board[y][i] || board[y][i][0] !== piece[0]) moves.push({x: i, y}); else break;
        for (let i = x - 1; i >= 0; i--) if (!board[y][i] || board[y][i][0] !== piece[0]) moves.push({x: i, y}); else break;
        for (let i = y + 1; i < 8; i++) if (!board[i][x] || board[i][x][0] !== piece[0]) moves.push({x, y: i}); else break;
        for (let i = y - 1; i >= 0; i--) if (!board[i][x] || board[i][x][0] !== piece[0]) moves.push({x, y: i}); else break;
      }

      // Knight
      if (piece[1] === 'n') {
        const knightMoves = [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]];
        for (let [dx, dy] of knightMoves) {
          let newX = x + dx, newY = y + dy;
          if (newX >= 0 && newX < 8 && newY >= 0 && newY < 8 && (!board[newY][newX] || board[newY][newX][0] !== piece[0])) {
            moves.push({x: newX, y: newY});
          }
        }
      }

      // Bishop
      if (piece[1] === 'b') {
        for (let i = 1; x + i < 8 && y + i < 8; i++) if (!board[y + i][x + i] || board[y + i][x + i][0] !== piece[0]) moves.push({x: x + i, y: y + i}); else break;
        for (let i = 1; x - i >= 0 && y - i >= 0; i++) if (!board[y - i][x - i] || board[y - i][x - i][0] !== piece[0]) moves.push({x: x - i, y: y - i}); else break;
        for (let i = 1; x + i < 8 && y - i >= 0; i++) if (!board[y - i][x + i] || board[y - i][x + i][0] !== piece[0]) moves.push({x: x + i, y: y - i}); else break;
        for (let i = 1; x - i >= 0 && y + i < 8; i++) if (!board[y + i][x - i] || board[y + i][x - i][0] !== piece[0]) moves.push({x: x - i, y: y + i}); else break;
      }

      // Queen (Rook + Bishop)
      if (piece[1] === 'q') {
        // Rook moves
        for (let i = x + 1; i < 8; i++) if (!board[y][i] || board[y][i][0] !== piece[0]) moves.push({x: i, y}); else break;
        for (let i = x - 1; i >= 0; i--) if (!board[y][i] || board[y][i][0] !== piece[0]) moves.push({x: i, y}); else break;
        for (let i = y + 1; i < 8; i++) if (!board[i][x] || board[i][x][0] !== piece[0]) moves.push({x, y: i}); else break;
        for (let i = y - 1; i >= 0; i--) if (!board[i][x] || board[i][x][0] !== piece[0]) moves.push({x, y: i}); else break;
        // Bishop moves
        for (let i = 1; x + i < 8 && y + i < 8; i++) if (!board[y + i][x + i] || board[y + i][x + i][0] !== piece[0]) moves.push({x: x + i, y: y + i}); else break;
        for (let i = 1; x - i >= 0 && y - i >= 0; i++) if (!board[y - i][x - i] || board[y - i][x - i][0] !== piece[0]) moves.push({x: x - i, y: y - i}); else break;
        for (let i = 1; x + i < 8 && y - i >= 0; i++) if (!board[y - i][x + i] || board[y - i][x + i][0] !== piece[0]) moves.push({x: x + i, y: y - i}); else break;
        for (let i = 1; x - i >= 0 && y + i < 8; i++) if (!board[y + i][x - i] || board[y + i][x - i][0] !== piece[0]) moves.push({x: x - i, y: y + i}); else break;
      }

      // King
      if (piece[1] === 'k') {
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            let newX = x + dx, newY = y + dy;
            if (newX >= 0 && newX < 8 && newY >= 0 && newY < 8 && (!board[newY][newX] || board[newY][newX][0] !== piece[0])) {
              moves.push({x: newX, y: newY});
            }
          }
        }
      }

      return moves;
    }

    // AI (Minimax with depth 2 for difficulty)
    function getAIMove() {
      let bestMove = null;
      let bestScore = -Infinity;
      for (let y = 0; y < 8; y++) {
        for (let x = 0; x < 8; x++) {
          if (board[y][x] && board[y][x][0] === 'b') {
            const moves = getMoves(board[y][x], x, y);
            for (let move of moves) {
              const newBoard = board.map(row => [...row]);
              newBoard[move.y][move.x] = newBoard[y][x];
              newBoard[y][x] = '';
              const score = minimax(newBoard, 2, false, -Infinity, Infinity);
              if (score > bestScore) {
                bestScore = score;
                bestMove = {from: {x, y}, to: move};
              }
            }
          }
        }
      }
      if (bestMove) {
        board[bestMove.to.y][bestMove.to.x] = board[bestMove.from.y][bestMove.from.x];
        board[bestMove.from.y][bestMove.from.x] = '';
        turn = 'w';
      }
    }

    function minimax(board, depth, isMaximizing, alpha, beta) {
      if (depth === 0) return evaluateBoard(board);
      if (isMaximizing) {
        let maxEval = -Infinity;
        for (let y = 0; y < 8; y++) {
          for (let x = 0; x < 8; x++) {
            if (board[y][x] && board[y][x][0] === 'b') {
              const moves = getMoves(board[y][x], x, y);
              for (let move of moves) {
                const newBoard = board.map(row => [...row]);
                newBoard[move.y][move.x] = newBoard[y][x];
                newBoard[y][x] = '';
                const eval = minimax(newBoard, depth - 1, false, alpha, beta);
                maxEval = Math.max(maxEval, eval);
                alpha = Math.max(alpha, eval);
                if (beta <= alpha) break;
              }
            }
          }
        }
        return maxEval;
      } else {
        let minEval = Infinity;
        for (let y = 0; y < 8; y++) {
          for (let x = 0; x < 8; x++) {
            if (board[y][x] && board[y][x][0] === 'w') {
              const moves = getMoves(board[y][x], x, y);
              for (let move of moves) {
                const newBoard = board.map(row => [...row]);
                newBoard[move.y][move.x] = newBoard[y][x];
                newBoard[y][x] = '';
                const eval = minimax(newBoard, depth - 1, true, alpha, beta);
                minEval = Math.min(minEval, eval);
                beta = Math.min(beta, eval);
                if (beta <= alpha) break;
              }
            }
          }
        }
        return minEval;
      }
    }

    function evaluateBoard(board) {
      let score = 0;
      for (let y = 0; y < 8; y++) {
        for (let x = 0; x < 8; x++) {
          if (board[y][x]) {
            const value = { 'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9, 'k': 100 }[board[y][x][1]];
            score += (board[y][x][0] === 'b' ? 1 : -1) * value;
          }
        }
      }
      return score;
    }

    // Touch and click handler
    function handleInteraction(e) {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.touches ? e.touches[0].clientX : e.clientX) - rect.left) / cellSize;
      const y = Math.floor((e.touches ? e.touches[0].clientY : e.clientY) - rect.top) / cellSize;
      if (x >= 0 && x < 8 && y >= 0 && y < 8) {
        if (selected && getMoves(board[selected.y][selected.x], selected.x, selected.y).some(m => m.x === x && m.y === y)) {
          board[y][x] = board[selected.y][selected.x];
          board[selected.y][selected.x] = '';
          selected = null;
          turn = 'b';
          setTimeout(getAIMove, 500); // AI move after delay
        } else {
          const piece = board[y][x];
          if (piece && piece[0] === turn) {
            selected = {x, y};
          } else {
            selected = null;
          }
        }
        drawBoard();
      }
    }

    // Event listeners
    canvas.addEventListener('click', handleInteraction);
    canvas.addEventListener('touchstart', handleInteraction, { passive: false });

    // Resize handler
    window.addEventListener('resize', () => {
      cellSize = Math.min(window.innerWidth * 0.9 / 8, 60);
      canvas.width = cellSize * 8;
      canvas.height = cellSize * 8;
      drawBoard();
    });

    // Initialize game after images load
    function initializeGame() {
      drawBoard();
    }

    // Start loading
    loadImages();
  </script>
</body>
</html>
